/*
    自由課題:「一般化した数独の自動問題作成」

    ※「数独」はパズル制作会社ニコリの登録商標です。

    以下、x, * は乗算を表すものとする。

    (1)実行方法, 実行例
    [実行方法]
    "go."で実行できる。実行すると、数独の1つのブロックサイズ(M x N)を入力するように求められる。
    まず、Mの値を入力し、次にNの値を入力する。その後、問題のレベルを入力をする。
    入力においては、数値の後にピリオドを入力してください。
    すると、作成された問題とその答えが表示される。
    作成される問題の大きさは M*N x M*N となる。

    ※[注意] M*Nの値が大きすぎると、待ち時間が増大するため、下記の表を目安にしてください。
    (M*Nの値に対するLevelと時間の目安)
     M x N | Levelの上限 | 時間@cse 
     1～11 |   上限なし  | 1s～5s   
    12～17 |      5      | 5s～15s  
    18～23 |      3      | 5s～20s  
    24～35 |      1      | 6s～40s  
    36～42 |      1      | 40s～100s
    43～   |      1      | 不明     

    [実行例]
    ?- go.
    Size of block is M x N.
    If you let both M and N be 3, it is a normal sudoku.
    Input a value of M. :
    |: 3.
    Input a value of N. :
    |: 3.
    Choose the level of the problem. : 1. 2. 3. 4. 5. max.
    |: max.
    Please wait...
    Created Problem
    +-----+-----+-----+
    |_ _ _|_ _ 4|8 6 _|
    |_ 5 _|_ _ _|_ _ _|
    |4 _ _|_ _ 8|_ 1 _|
    +-----+-----+-----+
    |_ _ 3|7 _ 6|_ _ 5|
    |2 _ _|_ _ _|_ 8 9|
    |1 _ _|_ _ _|6 _ _|
    +-----+-----+-----+
    |_ 9 _|2 _ _|_ _ _|
    |_ _ _|1 4 _|_ _ _|
    |8 _ 2|_ _ _|_ _ _|
    +-----+-----+-----+
    Answer
    +-----+-----+-----+
    |3 1 9|5 7 4|8 6 2|
    |7 5 8|6 1 2|9 3 4|
    |4 2 6|3 9 8|5 1 7|
    +-----+-----+-----+
    |9 8 3|7 2 6|1 4 5|
    |2 6 5|4 3 1|7 8 9|
    |1 7 4|8 5 9|6 2 3|
    +-----+-----+-----+
    |5 9 1|2 8 3|4 7 6|
    |6 3 7|1 4 5|2 9 8|
    |8 4 2|9 6 7|3 5 1|
    +-----+-----+-----+
    true.
    
    ?- go.
    Size of block is M x N.
    If you let both M and N be 3, it is a normal sudoku.
    Input a value of M. :
    |: 3.
    Input a value of N. :
    |: 4.
    Choose the level of the problem. : 1. 2. 3. 4. 5. max.
    |: 5.
    Please wait...
    Created Problem
    +-----------+-----------+-----------+
    |__ __ 12  6|__ __  2 __|__  1 __ __|
    |__  2 __  4|__ __ 12 __|__ 10 __  6|
    |10 __ __ __|__  8  9 __|__ __ __  2|
    +-----------+-----------+-----------+
    | 3 11 __ __| 7 __ __ __|__ __  1 __|
    | 8 __ __ 12|10  1 __  2|__ __ __  7|
    |__ __ __  7|__ __ __ __|11 __ __ __|
    +-----------+-----------+-----------+
    |__ 12  2 11| 8 __ __  4|__  9  5 __|
    | 6 __ __ __| 9 __  7 12| 2  4 __ 10|
    |__  4 __  8| 5 __ __  1|__  7 __ 11|
    +-----------+-----------+-----------+
    | 2 __ __ __|__ __ __  7| 6 __  9 __|
    |__ __ __ __|11 __  8 __| 3 __ __  4|
    |__  8  4 __|__  6 __  3|__ __ 12 __|
    +-----------+-----------+-----------+
    Answer
    +-----------+-----------+-----------+
    |11  9 12  6| 4  7  2 10| 8  1  3  5|
    | 1  2  8  4| 3  5 12 11| 9 10  7  6|
    |10  5  7  3| 1  8  9  6| 4 12 11  2|
    +-----------+-----------+-----------+
    | 3 11  5  2| 7 12  4  8|10  6  1  9|
    | 8  6  9 12|10  1 11  2| 5  3  4  7|
    | 4 10  1  7| 6  3  5  9|11  8  2 12|
    +-----------+-----------+-----------+
    | 7 12  2 11| 8 10  6  4| 1  9  5  3|
    | 6  1  3  5| 9 11  7 12| 2  4  8 10|
    | 9  4 10  8| 5  2  3  1|12  7  6 11|
    +-----------+-----------+-----------+
    | 2  3 11 10|12  4  1  7| 6  5  9  8|
    |12  7  6  1|11  9  8  5| 3  2 10  4|
    | 5  8  4  9| 2  6 10  3| 7 11 12  1|
    +-----------+-----------+-----------+
    true.

    (2)テーマ名とテーマ選択理由, 参考にした文献
    [テーマ名]
    一般化した数独の自動問題作成

    [テーマの概要]
    普通の数独は9 x 9のマスがあり、縦、横、3 x 3ブロックで1～9の数字が被らないように埋めていくパズルである。(下の図1参照)
    これを一般化すると、M x NのブロックをN x M個並べた盤面において、
    縦、横、M x Nのブロックで1～MNの数字が被らないように埋めていくパズルとなる。(下の図2参照)
    上記のM=3, N=3の時が、普通の数独である。この一般化した数独において、M, Nをユーザーが与えたときに、その問題を作成するプログラムを作る。
    ここで、"問題"とは解が一意に決まるものと定める。

    図1 : 普通の数独        図2 : M=3, N=4の場合の数独 (1～12の数字が入る)
    +-----+-----+-----+     +-----------+-----------+-----------+
    |_ 2 _|_ 1 5|_ 8 3|     |__  7 __ __| 4  6 __  5| 9 10 __ __|
    |_ _ 6|3 _ _|_ 4 _|     |__ 10 __  6|__ __  8 __| 5  7  3 __|
    |3 _ _|6 8 _|9 _ _|     |__  2  3  5| 9 __  7 10|__ __ __  1|
    +-----+-----+-----+     +-----------+-----------+-----------+
    |7 _ _|_ _ _|_ 2 _|     |__ __ __ __|__ __ __ __|__ __ 11  8|
    |_ 1 2|4 _ _|_ 6 _|     |11 12 __ 10|__ __ __ __| 3  9 __  5|
    |_ _ _|9 _ 2|_ _ _|     |__ __ __  2|11 __  9 __| 7 __ __ 10|
    +-----+-----+-----+     +-----------+-----------+-----------+
    |9 _ _|2 _ _|4 5 _|     |__  5 __ __|__  9 __ __|__ __ __ __|
    |2 _ 1|5 9 6|8 _ _|     |__  8 __ __|__ 11 __ __|10 __ __ 12|
    |6 7 _|_ _ 3|2 _ 1|     | 9 11 __ __| 1  3 10  4|__ __ __ __|
    +-----+-----+-----+     +-----------+-----------+-----------+
                            |__ __  2 11|__ __ __  9|12  6 __  7|
                            |__  6  5 __|__  7 __ 12| 2  8  1 __|
                            | 7 __ __ __|__ __  2  8| 4 __ __ __|
                            +-----------+-----------+-----------+

    [テーマ選択の理由]
    数独の問題を自動的に作成することに興味があったため、最初は、普通の9 x 9数独の問題作成プログラムを考えていた。
    しかし、普通の数独ソルバーがSWI-Prologのhelp(transpose)に載っていることに気付いた。
    数独を解く機能は問題作成の一部であり、なるべく新規性のあるものを作ろうと考えていたので、
    数独を一般化して、一般化された数独の問題作成を行うことにした。

    [テーマを選ぶ上で参考にしたサイト]
    テーマを考える際に、下記のサイトに載っていないものから選んだが、結局、2016/07/02に追加されてしまった。
    お気楽 Prolog プログラミング入門 http://www.geocities.jp/m_hiroi/prolog/

    (3)アルゴリズム/データ構造の説明

    [数独の盤面のデータ構造]
    説明のためM=2, N=3の数独を用いる。
    +-----+-----+
    |2 1 6|3 4 5|
    |5 4 3|1 2 6|
    +-----+-----+
    |4 5 1|2 6 3|
    |6 3 2|4 5 1|
    +-----+-----+
    |3 6 4|5 1 2|
    |1 2 5|6 3 4|
    +-----+-----+
    上記の盤面を次のように、リストのリストで表す。
    [[2,1,6,3,4,5]
     [5,4,3,1,2,6]
     [4,5,1,2,6,3]
     [6,3,2,4,5,1]
     [3,6,4,5,1,2]
     [1,2,5,6,3,4]]

    ブロックの大きさ情報は、リストとは別に変数M, N が保持している。
    また、数独の問題では空白が必要となるが、変数が空白を表すものとする。

    [問題作成アルゴリズム]
    M x Nのブロックを持つ数独を考える。
    つまり、盤面のサイズは M*N x M*N である。

    1. 完成した盤面(全て数字が埋まった状態)を用意する。
    2. 0 から (M*N x M*N - 1) の重複なしランダム列のリストを得る。
    3. ランダム列に従い、盤面に空白をあけていく。
       具体的には、ランダム列が[R1, R2, R3, ...]とあったとすると、
       I = R1 div (M*N), J = R1 mod (M*N)
       として、盤面における(行, 列)=(I, J)を求める。
       そして、(I, J)の位置を空白にする。
       その後、R2, R3, ...について同様の動作をする。
    4. 3.の空白をあける各ステップにおいて、
       空白をあけた際に解が複数存在したら(以下、穴あけ失敗という)、あけた空白を元に戻し、
       次の場所の穴あけステップに移る。
    5. ランダム列の最後まで穴あけステップを行った or 穴あけ失敗回数が指定された回数に達したら、
       そのときの盤面を出力する。
       このとき出力された盤面が作成された問題である。

    [数独を解くアルゴリズム]
    上記の問題作成アルゴリズムの4.において、「解が複数存在」するかどうかを確かめるために、
    問題を解くプログラムが必要になる。そのアルゴリズムについて説明する。

    制約充足プログラミング用のライブラリを用いると簡単に書けたのでそれを説明する。
    以下では、問題の空白は、変数で表されているとする。

    1. 各行について、1からM*N の値を持ち、全て異なると制約を付ける。
    2. 各列を取り出し、1からM*Nの値を持ち、全て異なると制約を付ける。
    3. 各M x Nのブロックを取り出し、1からM*Nの値を持ち、全て異なると制約を付ける。
    4. 1.から3.の条件の下で、最も領域の少ない変数から値割り当て(ラベリング)をする。

    [盤面の完成形作成アルゴリズム]
    問題作成アルゴリズムの1.において、完成した盤面の作成が必要であった。
    その作成アルゴリズムをここで説明する。

    盤面の作成アルゴリズムは、確実に作成するアルゴリズム と 確率的に作成するアルゴリズム の2つを考えた。
    確実に作成するアルゴリズムは、必ず盤面を作成することができるが、
    盤面のサイズが大きくなると計算量的に機能しなくなるアルゴリズムで、
    確率的に作成するアルゴリズムは、確率的に盤面を作成し、必ず作成できるとは限らないが、
    ある程度盤面が大きくなっても通用するアルゴリズムである。

    (確実に作成するアルゴリズム)
    1. 全て空白(変数)である盤面を用意する。
    2. [数独を解くアルゴリズム]の1.2.3.のように各行、各列、各ブロックに制約を付ける。
    3. 各行に対して、順に4. 5.の処理を行う。
    4. 1からM*Nの重複なしランダム列のリストを用意する。
    5. 制約の条件下で、そのランダム列を基準とする順列を考えて、
       制約を満たすものがあればその行の値をその順列に決定し、次の行の作成へ。
       どの順列も制約を満たさなければ、前の行の決定を解除し、別の順列を探す。
    6. 3.において、全ての行が決定したとき、それを完成形の盤面とする。

    (確率的に作成するアルゴリズム)
    1. 全て空白(変数)である盤面を用意する。
    2. [数独を解くアルゴリズム]の1.2.3.のように各行、各列、各ブロックに制約を付ける。
    3. 各行について、その行を確率的に作成できるか K1回 4. をチャレンジする。
       作成できたら、次の行の作成へ。
       1回も作成できなければ、前の行の作成試行の途中へもどる。(バックトラック)
    4. その行の各マスについて、そのマスを作成できるか K2回 5. をチャレンジする。
       作成できれば、次の値の作成へ。
       1回も作成できなければ、4. は失敗とする。
    5. 1からM*N以下のランダム値を1つ得て、そのマスに値をセットできるかチャレンジする。
    6. 3.において全ての行の値を決定できたとき、それを完成形の盤面とする。

    運が悪かったり、K1やK2の値が小さいと、作成に失敗してしまう。
    実装においては 経験的に K1 = M*N*2, K2 = M*N*2 としている。(この調整は重要である)

    確実に作成するアルゴリズムは、M=4, N=4程度が限界である。
    一方、確率的に作成するアルゴリズムはM=6, N=6でも5sくらいで作成できる。
    確率的に作成するアルゴリズムで失敗した事がないので、
    確実に作成するアルゴリズムの方は呼び出し元でコメントアウトしている。

    (4)述語の説明
    [表示関連]
    printRows(M, N, Rows):
        ブロックがM x Nである数独の盤面Rowsの表示
    printRows(K, M, N, Keta, Rows):
        printRows/3実現用の述語。M x Nのブロックの数独の表示。Ketaは数字の最大桁数を、Kは現在の行番号を表す。
    printRow(K, N, Keta, Row):
        printRows/5実現用の述語。行Rowを出力していく。Ketaは数字の最大桁数を、Kは現在の列番号を表す。
    writeN(N, Atom):
        AtomをN回出力する
    writeLine(M, N, Keta):
        数独の盤面の横線を引く述語。M x Nブロックの数独の盤面の線を引く。Ketaは数字の最大桁数。

    [解く関連]
    solve(M, N, Rows):
        M x Nブロックを持つ数独を解く。Rowsは数独のデータ構造。
    restrict(MN, L):
        リストL内の変数は、「1からMNまで数値を持ち、互いに異なる」という制約を付ける。
    rows(MN, Rows):
        数独のデータ構造Rowsが与えられた時に、行に対する制約を付ける。MNは数独に入れる数値の最大値。
    cols(MN, Rows):
        数独のデータ構造Rowsが与えられた時に、列に対する制約を付ける。MNは数独に入れる数値の最大値。
    blocks(M, N, MN, Rows):
        数独のデータ構造Rowsが与えられた時に、M x Nブロックに対する制約を付ける。MNは数独に入れる数値の最大値。
    blocks(N, MN, Rows):
        blocks/4実現用の述語。M行のリストRowsをN個ごとに区切り、制約を付ける。MNは数独に入れる数値の最大値。
    cross(MN, Rows):
        数独のデータ構造Rowsが与えられた時に、対角線に対する制約を付ける。MNは数独に入れる数値の最大値。
        対角線に制約を加えた数独もあるようなので用意してみた。今回は使っていない。
    selectN(N, List1, List2, List3):
        List1の先頭からN個取り出したリストList2と、残りのリストList3を返す。
    flat(List, Flat):
        ListをフラットにしたリストFlatを返す。ただし、Listはリストのリストであることが前提で、1段階のみフラットにする。
    appendVar(L1, L2, L3):
        リストL1から変数のみ取り出したリスト と L2 を結合したリストL3を返す。
    flatVar(List, Flat):
        Listから変数のみ取り出し、フラットにしたリストFlatを返す。ただし、Listはリストのリストであることが前提で、1段階のみフラットにする。

    [完成形作成関連]
    createResult(M, N, List):
        M x Nブロックを持つ数独の完成形Listを確実に返す。(確実に作成するアルゴリズム)
    getVars(N, L):
        N個の変数が入ったリストLを返す。
    getVars(M, N, L):
        M x N 個の変数のリストLを返す。Lは、リストのリストとなる。
    createRow(MN, Row):
        行Rowをランダムに作る。ただし、Rowには制約がかけられているものとする。MNは数独に入れる数値の最大値。
    randList(Low, High, L):
        LowからHighまでの重複なしランダムリストLを求める。
    createResultHeuristic(M, N, Rows):
        M x Nブロックを持つ数独の完成形Listを返す。(確率的に作成するアルゴリズム)
    tryRow(K1, MN, Row):
        数独の行Rowを作れるかどうかK1回チャレンジする。MNは数独に入れる数値の最大値。
    tryValue(K2, MN, X):
        変数Xの値を1からMNまでのランダム値に決める。ただし、Xには制約がかかっており、K2回チャレンジして条件を満たさない時は失敗する。

    [問題作成関連]
    create(M, N, Level): 
        M x Nブロックを持つ数独の問題作成と表示。Levelは難易度(最大穴あけ失敗回数)を表す。
    createProblem(M, N, Problem, Ans, Level):
        M x Nブロックを持つ数独の問題作成。問題Problemと答えAnsを返す。Levelは難易度(最大穴あけ失敗回数)を表す。
    setBlank(M, N, MN, List, Ans, RandList, Problem, Level):
        M x Nブロックを持つ数独に穴を開ける述語。
        Listは現在の穴あけ状態、Ansは答え、RandListは穴開け順序のリスト、
        Problemは穴あけの最終結果、Levelは最大穴あけ失敗回数を表す。
    diff(M, N, Problem, Ans):
        M x Nブロックを持つ数独が複数の解を持つか調べる述語。Problemは問題、Ansは答えを表す。Ans以外の解を持つときtrue。
    replace(I, J, X, L1, L2):
        リストのリストL1の(I, J)をXで置換したリストL2を返す。
    replace(N, X, L1, L2):
        リストL1のN番目をXで置換したリストL2を返す。

    [実行関連]
    go:
        実行用述語。ブロックサイズM, N、難易度Levelを入力させ、数独の問題を作成する。
    create:
        [盤面の完成形作成アルゴリズム]の実行時間の比較ができる。
    test:
        solve/3の動作確認用。

    (5)考察
    [工夫したところ]
    1. データ構造の決定について
    データ構造の候補として、「1次元のリスト」と、「リストのリスト」があった。
    「リストのリスト」にした理由は、要素(I, J)へのアクセスの容易性である。
    リストは配列のようにランダムアクセスできないので、アクセスコストをなるべく小さくする必要がある。
    要素(I, J)へのアクセスは、「1次元のリスト」であると、I x M*N+J回、順次アクセスしなければならない。
    一方、「リストのリスト」であると、I+J回の順次アクセスで済む。
    そのため、アクセスコストの低い「リストのリスト」を選択した。

    2. プログラムの簡易化をはかった
    最初、複数の規則で書いていたところをmaplistをうまく用いて、規則の数を減らして見やすくした。
    また、何度も試行するところを再帰ではなく、between/3を用いて簡略化した。

    3. 穴あけの効率を良くした
    最初考えた穴あけの方法は、次の通り。

    0からMN-1のランダム値を2つ得て、I, Jとする。
    盤面の(I, J)が既に空白かどうか調べ、空白なら別のランダム値の組(I, J)を得る。
    空白でないなら、(I, J)を空白にする。

    この方法は、得たランダム値(I, J)が空白かどうかをいちいち調べなければならない。
    その度、アクセスコストI+J と 変数か調べるコスト が生じる。
    これを回避するために、盤面の各マスに I*MN+J の番号を対応させ、
    0からMN*MN-1の重複なしランダム列に従い穴を開ける方法を思いついた。
    この方法の利点は、穴を開ける対象のマスが必ず空白でないと保証されているところである。

    4. 盤面の表示方法の工夫
    盤面の表示において、最大桁数を求めて、その桁数に合わせるようにスペースを入れて、
    桁数が違う数字同士でずれないようにした。
    また、ひと目でブロックサイズ(M x N)がわかるように、線を引くようにした。

    5. Fast Fail戦略で計算量を減らした
    数独を解く機能は、解が複数あるかどうか調べるために用いるため、
    1つの解だけでなく、全ての解の可能性を探索する必要がある。
    全探索では、盤面のサイズの増大に伴い計算量が大きく増大してしまうため、探索順序が重要になってくる。
    そのため、数独の盤面の全てのマスで、最も取りうる値の種類が少ないマスから値を決定するようにした。(Fast Fail)

    6. 効率化を考えて改善を重ねた
    プログラムの候補が複数ある場合、time/1を用いて比較し、より効率のよい方を選んだ。
    以下に実際に行った例を示す。

    (例1)「リストのリスト」の平滑化
    組み込み述語flatten/2は、どんなリストでも平滑化するため、その分コストがかかる。
    そのため、リストの要素がリストであることを前提とした1段階の平滑化を行う述語flatを作成した。

    (例2)labelingの性質
    labeling([ff], [X]) と labeling([ff], [1, 2, X])
    この2つのコストは大幅に違う。
    後者のように、ラベリング対象に余分な定数が入ると、コストが大きくなる。
    したがって、ラベリング時に、既に決定しているものを渡さないようにした。

    (例3)制約がかかった下での順列生成
    リストLには、制約がかかっているものとする。
    permutation([1,2,3], L). と permutation([1,2,3], X), X=L.
    この2つは、一見同じことをしているように見えるが効率が圧倒的に違う。
    後者は、順列Xを生成してから、Lの制約に当てはまるか調べているため、Xが階乗のオーダーで生成される。
    前者は、制約のもとでの順列生成で、枝刈りされるため効率が良い。

    (例4)機能の結合による効率化
    リストの平滑化 と リストから変数のみを取り出す機能 を考える。
    flat(Rows, Flat), vars(Flat, Vars). と flatVar(Rows, Vars). を比較する。
    flat/2は、平滑化する述語。vars/2は、変数のみ取り出す述語とする。flatVar/2は、平滑化と同時に変数のみを取り出す述語とする。
    前者は、平滑化後に、変数を取り出すが、
    flatの内部で、append/3を用いており、append/3は内部で各要素にアクセスしている。
    そして、vars/2でも各要素にアクセスする必要がある。
    各要素に2回ずつアクセスすることになるので、無駄である。
    この無駄を省くために、平滑化と同時に変数のみ取り出す述語flatVar/2を定義した。

    7. 末尾再帰を意識した
    処理系にもよるが、末尾再帰は内部で最適化されるようなので、再帰はすべて末尾再帰にした。

    8. 問題のレベルを設定できるようにしたこと
    最大穴あけ失敗回数をレベルとしている。
    レベルを上げる事で、統計的には穴を開ける数が増えることになる。
    一般に、空白の数と難易度は絶対的な相関があるわけではないが、
    全体的には、空白が多くなれば難しくなるのは事実である。

    [完成形作成のアルゴリズムの比較]
    完成形作成のアルゴリズムの説明で、2つのアルゴリズムを示した。
    それらのアルゴリズムの実行時間を比較する。

    M | N |M*N| 確率的  | 確実
    3 | 3 | 9 |  0.013s | 0.013s
    4 | 4 |16 |  0.079s | 1.24 s
    4 | 5 |20 |  0.19 s | 200s待っても終わらないことがある
    5 | 5 |25 |  0.55 s |
    5 | 6 |30 |  1.2  s |
    6 | 6 |36 |  6.7  s |
    6 | 7 |42 | 20    s |
    7 | 7 |49 | 76    s |

    確率的の方が圧倒的に速いことがわかる。

    [問題点と改善点]
    現在のプログラムは、非常にシンプルになっているが決して改善を怠ったわけではない。
    いろいろ改善を考えて結果的に現在のプログラムになっている。
    そのことをわかっていただくために、下記を見ていただきたい。

    問題点1:
    盤面に空白を開けるたびに、solveを呼ぶというのが無駄であるように思える。(solveは問題を解く述語)
    そこで、改善しようといろいろ試してみたが、よりコストが大きくなってしまった例をあげる。

    (改善案)solveを呼ばないようにする
    アイデア:
    solveの内部で、「行の制約rows」,「列の制約cols」,「ブロックの制約blocks」,「平滑化」を行っており、
    呼び出されるたびに実行するのは無駄なので、事前に制約をかけた変数(M*N x M*Nのリストのリスト)を用意しておく。
    その変数をSTとし、STを平滑化したものをStFlatとする。
    アルゴリズム:
    1. 完成形からいくつか空白を開けた盤面を表す変数をLとする。
    2. 解を求める際に、 ST=L とすればSTに盤面の状態が入る。
    3. STには既に制約があるので、ラベリングすれば解が求まる。( labeling([ff], StFlat) )

    実際にこれを実装して、実行してみると余計に遅くなった。
    その理由は、アルゴリズム: 2. の ST=L にある。
    制約がかかっていない状態でのマッチング(e.g. time( [X,Y,Z]=[1,2,3] ). )を実行すると「1 inferences」と出る。
    しかし、制約がかかった状態でのマッチング(e.g. L=[X,Y,Z], L ins 1..9, all_different(L), time( L=[1,2,3] ). )は「209 inferences」と出た。
    これは、マッチングする際に、「insの範囲内に入っているかどうか」、ある変数が具体化された時に、「他の変数の領域を狭める(伝播させる)」
    作業を行っているからだと予想できる。
    そのため、この改善案は余計に「制約, 平滑化」のコストがかかり、失敗に終わった。

    問題点2:
    空白を開ける際に(I, J)にアクセスするコストが無駄である。

    (改善案)空白を開ける際に(I, J)にアクセスしないようにする。
    アイデア:
    Lが「リストのリスト」であり、それを平滑化したものLFlatがあるとき、
    LFlatのある要素の値が具体化された時、同時にLの要素も具体化されている事を利用する。

    準備:
    変数(M*N x M*Nのリストのリスト)を用意しておく。これをLとする。Lを平滑化したものをLFlatとする。
    完成形をAnsとする。Ansを平滑化したものをAnsFlatとする。
    2つのリストを同じ順序でランダムに並び替える述語randがあるとする。( e.g. rand([1,2,3],[a,b,c],X,Y)  --->  X=[2,1,3],Y=[b,a,c] )
    rand(LFlat, AnsFlat, LRand, AnsRand)により、LRand, AnsRandを求める。

    アルゴリズム:
    1. LRand, AnsRandを先頭から順に最後まで再帰的にマッチングさせる。(このとき、Lは全て埋まった状態になる)
    2. 最後まで埋まったら、failさせ、1つマッチングを解除させる。(空白を開けるに相当する)
    3. このとき、solveに解かせて、解が1つなら、failさせる。(空白を開けるに相当する) 解が複数なら1つ穴あけを戻して、終了する。
    4. 3を解が2つ以上になるまで繰り返す

    これで、(I, J)へアクセスは必要なくなった。
    しかし、このアルゴリズムは、1回穴あけに失敗すると終了してしまう。(できるだけ穴を開けるという試行ができない)
    また、実際にこれも実装してみたが、大きな差は見られなかった。

    問題点3:
    盤面のサイズの増大に伴い、完成形作成 と 問題を解く機能 の計算量が急激に増大してしまう点。
    これを改善しようと思っても、解く機能は上記のようにFast Fail戦略に基づいており、これ以上効率化を図るのが難しい。
    完成形作成は、さらに効率化できる可能性があると考え、さまざまな方法を試してみたが失敗に終わった。
    それに、たとえ完成形作成の効率化がうまくいっても、解く機能の方が計算量の支配項になるため問題解決にはならない。

    問題点4:
    穴あけアルゴリズム自体が非効率に思える点。
    毎回同じような問題を解いているので、無駄を省ける可能性がある。
    しかし、次の通り、これは難しい。たとえば、今、穴あけ途中の盤面において穴を開けたとする。
    このときこの問題の解が1つだけか調べるときに、今開けた穴がすぐに埋まり前の状態に戻れば、
    すぐに解が1つであるとわかるが、一般にそうはいかない。
    他の空白が決まってからその空白が決まる場合がほとんどであるからだ。

    [参考文献のリスト]
    効率的なProlog: 実践ガイド http://ratiwo.blogspot.jp/2008/06/prolog_30.html
    制約論理プログラミング超入門 http://www.geocities.jp/m_hiroi/prolog/clp.html
    数独Wikipedia https://ja.wikipedia.org/wiki/%E6%95%B0%E7%8B%AC
    お気楽 Prolog プログラミング入門 http://www.geocities.jp/m_hiroi/prolog/
    SWI-Prologのhelp
*/


%制約充足プログラミング用ライブラリロード
:-use_module(library(clpfd)).

/*----------表示----------*/

%数独の盤面表示
printRows(M, N, Rows):-
    MN is M*N,
    %最大桁数Ketaを求める
    atom_length(MN, Keta),
    %0行目から順に表示させる
    printRows(0, M, N, Keta, Rows).

printRows(_, M, N, Keta, []):-
    %すべての行を表示し終えたら、横線を引く
    writeLine(M, N, Keta), !.
printRows(K, M, N, Keta, [H|T]):-
    %Mの倍数行目のとき、横線を引く
    (K mod M =:= 0, !, writeLine(M, N, Keta); true),
    %この行の0列目から順に各値を出力
    printRow(0, N, Keta, H),
    %次の行へ
    K1 is K + 1,
    printRows(K1, M, N, Keta, T).

printRow(_, _, _, []):-
    %最後まで表示し終えたら、縦線を引く
    writeln('|'), !.
printRow(K, N, Keta, [H|T]):-
    %定数のとき
    atomic(H), !,
    %桁数を求める
    atom_length(H, Len),
    %Nの倍数列目のとき、線を引く。また、桁数に応じたスペースの出力。
    (K mod N =:= 0, !, write('|'), tab(Keta - Len); tab(Keta - Len + 1)),
    write(H),
    %次の列へ
    K1 is K + 1,
    printRow(K1, N, Keta, T), !.

%変数のとき
printRow(K, N, Keta, [_|T]):-
    %Nの倍数列目のとき、線を引く。
    (K mod N =:= 0, !, write('|'); write(' ')),
    %空白の出力
    writeN(Keta, '_'),
    %次の列へ
    K1 is K + 1,
    printRow(K1, N, Keta, T).

%AtomをN回出力
writeN(N, Atom):-
    N1 is N,
    %N回繰り返す
    between(1, N1, X),
    write(Atom),
    X == N1, !.

%横線を引く
writeLine(M, N, Keta):-
    %M回繰り返す
    between(1, M, X),
    write('+'), writeN(N*(Keta+1)-1, '-'),
    X == M, writeln('+'), !.

/*----------解く----------*/

%数独を解く
solve(M, N, Rows):-
    MN is M*N,
    %行、列、ブロックの制約
    rows(MN, Rows), cols(MN, Rows), blocks(M, N, MN, Rows),
    %変数だけ取り出すと同時に、フラットにする
    flatVar(Rows, Flat),
    %最も領域の少ない変数から決定(ff)
    labeling([ff], Flat).

%Xは、1からMNまでの値を取り、すべて異なる
restrict(MN, L):- L ins 1..MN, all_different(L).

%行の制約
rows(MN, Rows):-
    maplist(restrict(MN), Rows).

%列の制約
cols(MN, Rows):-
    %転置する
    transpose(Rows, Cols),
    maplist(restrict(MN), Cols).

%ブロックの制約
blocks(_, _, _, []):- !.
blocks(M, N, MN, Rows):- 
    %M行分取り出す
    selectN(M, Rows, X, Y),
    %取り出したM行をN分割し、制約をかける
    blocks(N, MN, X),
    %残りの行に対して
    blocks(M, N, MN, Y).

blocks(_, _, [[]|_]):- !.
blocks(N, MN, Rows):-
    %各行の先頭からN個取り出す
    maplist(selectN(N), Rows, X, Y),
    %それらをフラットにする
    flat(X, Xf),
    restrict(MN, Xf),
    %残りに対して
    blocks(N, MN, Y).

%対角線の制約(今回は使っていない)
cross(MN, Rows):-
    %1からMNの列を得る
    numlist(1, MN, L1),
    %右下がりの対角線の取り出し
    maplist(nth1, L1, Rows, X),
    restrict(MN, X),
    reverse(L1, L2),
    %右上がりの対角線の取り出し
    maplist(nth1, L2, Rows, Y),
    restrict(MN, Y).

%先頭からN個取り出したリストと残りのリストを返す
selectN(0, R, [], R):- !.
selectN(N, [H|T], [H|X], R):-
    N1 is N - 1,
    selectN(N1, T, X, R).

%一段階のみフラットにする(リストの要素がリストであることが前提)
flat([H], H):- !.
flat([H|T], R):-
    %先頭のリスト と 残りをフラットにしたリスト を連結
    append(H, Flat, R),
    %残りをフラットにする
    flat(T, Flat).

%第1引数のリストから変数のみ取り出し、第2引数のリストと結合
appendVar([], L2, L2):- !.
appendVar([H1|T1], L2, [H1|T3]):-
    %変数のとき
    var(H1), !,
    %T1とL2を連結したものがT3
    appendVar(T1, L2, T3).
appendVar([_|T1], L2, L3):-
    %変数でないとき無視する
    appendVar(T1, L2, L3).

%変数のみ取り出し、一段階のみフラットにする(リストの要素がリストであることが前提)
flatVar([L1], L2):-
    %L1から変数だけ取り出す
    !, appendVar(L1, [], L2).
flatVar([H|T], R):-
    %先頭のリストから変数のみ取り出し、Flatと連結
    appendVar(H, Flat, R),
    %残りTをフラットにし、変数のみ取り出したものがFlat
    flatVar(T, Flat).

/*----------完成形作成----------*/

%確実に完成形を求めるが、MNが大きくなると実用性がなくなる
createResult(M, N, Rows):-
    MN is M*N,
    %MN x MNの変数を用意
    getVars(MN, MN, Rows),
    %行、列、ブロックの制約
    rows(MN, Rows), cols(MN, Rows), blocks(M, N, MN, Rows),
    %各行を作成
    maplist(createRow(MN), Rows), !.

%N個の変数をリストで返す
getVars(N, L):-
    %長さがNであるようなリストL
    length(L, N).
%M x N 個の変数を返す
getVars(M, N, L):-
    getVars(M, L),
    maplist(getVars(N), L).

%行を作る
createRow(MN, Row):-
    %1からMNのランダム列を得る
    randList(1, MN, Rand),
    %その順列からRowに当てはまるものをもとめる
    permutation(Rand, Row).

%LowからHighまでのランダムリストを求める
randList(Low, High, L2):-
    %LowからHighまでの数字列L1を得る
    numlist(Low, High, L1),
    %それをランダムに並び替えたものがL2
    random_permutation(L1, L2).

%完成形を確率的に求める
createResultHeuristic(M, N, Rows):-
    MN is M*N,
    %MN x MNの変数を用意
    getVars(MN, MN, Rows),
    %行、列、ブロックの制約
    rows(MN, Rows), cols(MN, Rows), blocks(M, N, MN, Rows),
    K1 is MN * 2,
    %各行を作成できるか、それぞれK1回チャレンジする
    maplist(tryRow(K1, MN), Rows), !.

%行を作成できるかK1回トライ
tryRow(K1, MN, Row):-
    K2 is MN * 2,
    %K1回チャレンジ
    between(1, K1, _),
    %この行の各値を決定できるか、それぞれK2回チャレンジする
    maplist(tryValue(K2, MN), Row).

%各値を決定できるかK2回トライ
tryValue(_, _, X):-
    %Xが定数なら、既に値は決まっている
    atomic(X), !.
tryValue(K2, MN, X):-
    %K2回チャレンジ
    between(1, K2, _),
    %1からMNのランダム値をXに入れられるかどうか
    X is random(MN) + 1, !.

/*----------問題作成----------*/

%問題作成と表示
create(M, N, Level):-
    %すべて整数
    integer(Level), integer(N), integer(M),
    writeln('Please wait...'),
    %M x Nブロックの数独の問題と答えを得る
    createProblem(M, N, Problem, Ans, Level),
    writeln('Created Problem'),
    printRows(M, N, Problem),
    writeln('Answer'),
    printRows(M, N, Ans).

%問題作成
createProblem(M, N, Problem, Ans, Level):-
    %完成形Ansの作成
    %createResult(M, N, Ans),
    createResultHeuristic(M, N, Ans),
    MN is M*N,
    MN2 is MN*MN - 1,
    %0からMN*MN-1のランダム列を得る
    randList(0, MN2, BlankList),
    %ランダム列に従い穴を開けていく
    setBlank(M, N, MN, Ans, Ans, BlankList, Problem, Level).

%空白を開ける
%カウントが0になったら終了
setBlank(_, _, _, Problem, _, _, Problem, 0):- !.
%または、ランダム列がなくなったら終了
setBlank(_, _, _, Problem, _, [], Problem, _):- !.
%List1の場所Hを穴あける
setBlank(M, N, MN, List1, Ans, [H|T], Problem, Level):-
    I is H div MN,
    J is H mod MN,
    %(I,J)を空白(変数)にする
    replace(I, J, _, List1, List2),
    %解が1つのみかどうか
    not(diff(M, N, List2, Ans)), !,
    %次の穴あけへ
    setBlank(M, N, MN, List2, Ans, T, Problem, Level).
%穴あけに失敗したとき
setBlank(M, N, MN, List1, Ans, [_|T], Problem, Level):-
    %穴あけ失敗をカウントに反映
    Lev1 is Level - 1,
    %次の穴あけへ
    setBlank(M, N, MN, List1, Ans, T, Problem, Lev1).

%解が複数出るとき真
diff(M, N, Problem, Ans):-
    %問題を解く
    solve(M, N, Problem),
    %Ans以外の解が出たらTrue
    Ans \== Problem, !.

%(I,J)をXで置換
replace(0, J, X, [H1|T], [H2|T]):-
    %J番目をXで置換
    replace(J, X, H1, H2), !.
replace(I, J, X, [H|T], [H|L]):-
    I1 is I - 1,
    replace(I1, J, X, T, L).

%リストのN番目の要素をXで置換
replace(0, X, [_|T], [X|T]):- !.
replace(N, X, [H|T], [H|L]):-
    N1 is N -1,
    replace(N1, X, T, L).

/*----------実行用----------*/

%実行用述語
go:-
    writeln('Size of block is M x N.'),
    writeln('If you let both M and N be 3, it is a normal sudoku.'),
    %ブロックサイズの読み取り
    writeln('Input a value of M. : '), read(M),
    writeln('Input a value of N. : '), read(N),
    %レベルを読み取り
    writeln('Choose the level of the problem. : 1. 2. 3. 4. 5. max.'), read(Input),
    %Levelを負にすると、できるだけ穴をあけることになる
    ( Input = max, !, Level = -1; Level = Input ),
    %問題作成と表示
    create(M, N, Level).

%完成形作成のアルゴリズムの比較用
create:-
    %確実に作成するアルゴリズム
    writeln('Time of createResult(4, 4, X):'),
    time(createResult(4, 4, X)),
    printRows(4, 4, X),
    %確率的に作成するアルゴリズム
    writeln('Time of createResultHeuristic(4, 4, X):'),
    time(createResultHeuristic(4, 4, Y)),
    printRows(4, 4, Y).

%solve/3動作確認用
test:-
    Rows = [
        [_,2,3,6,_,_],
        [_,_,_,_,3,_],
        [1,_,_,_,4,6],
        [_,3,_,2,_,_],
        [_,_,4,_,_,_],
        [_,_,_,_,_,_]
    ],
    M = 2, N = 3,
    solve(M, N, Rows),
    printRows(M, N, Rows).
